package git

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"time"

	"github.com/grpc-ecosystem/go-grpc-middleware/logging/logrus/ctxlogrus"
	"github.com/opentracing/opentracing-go"
	"gitlab.com/gitlab-org/labkit/correlation"
)

// trace2Event is used to deserialize the data generated by GIT_TRACE2
type trace2Event struct {
	Event   string    `json:"event"`
	Sid     string    `json:"sid"`
	Thread  string    `json:"thread"`
	Time    time.Time `json:"time"`
	File    string    `json:"file"`
	Line    int       `json:"line"`
	AbsTime float64   `json:"t_abs"`
	Code    int       `json:"code"`
}

// trace2
type trace2 struct {
	f *os.File
}

func enableTrace2(ctx context.Context, span opentracing.Span) ([]string, func(), error) {
	tmpFile, err := os.CreateTemp("", "gitaly-trace2.")
	if err != nil {
		return nil, nil, fmt.Errorf("Trace2 create tempfile: %w", err)
	}

	// Git will block unless someone reads from the pipe
	// so start a goroutine to continuously reads.
	go func() {
		dec := json.NewDecoder(tmpFile)
		var ev trace2Event

		span.LogKV("letsgo", "toon")

		for {
			err := dec.Decode(&ev)
			if err == nil {
				span.LogKV(
					"trace2.event", ev.Event,
					"trace2.sid", ev.Sid,
					"trace2.thread", ev.Thread,
					"trace2.time", ev.Time,
					"trace2.file", ev.File,
					"trace2.line", ev.Line,
					"trace2.t_abs", ev.AbsTime,
					"trace2.code", ev.Code)
			} else if errors.Is(err, os.ErrClosed) {
				break
			}
			// } else if !errors.Is(err, io.EOF) {
			// 	log.Println("the error %w", err)
			// }
		}
	}()

	// // Git will block unless someone reads from the pipe
	// // so start a goroutine to continuously reads.
	// go func() {
	// 	//dec := json.NewDecoder(tmpFile)
	// 	var ev trace2Event

	// 	span.LogKV("letsgo", "toon")

	// 	s := bufio.NewScanner(tmpFile)
	// 	s.Split(bufio.ScanLines)

	// 	for {
	// 		for s.Scan() {
	// 			err := json.Unmarshal([]byte(s.Text()), &ev)
	// 			//			err := dec.Decode(&ev)
	// 			if err == nil {
	// 				span.LogKV(
	// 					"trace2.event", ev.Event,
	// 					"trace2.sid", ev.Sid,
	// 					"trace2.thread", ev.Thread,
	// 					"trace2.time", ev.Time,
	// 					"trace2.file", ev.File,
	// 					"trace2.line", ev.Line,
	// 					"trace2.t_abs", ev.AbsTime,
	// 					"trace2.code", ev.Code)
	// 				// } else if errors.Is(err, os.ErrClosed) {
	// 				// 	break
	// 				// } else if !errors.Is(err, io.EOF) {
	// 				// 	log.Println("the error %w", err)
	// 				// }
	// 			}
	// 		}
	// 		if errors.Is(s.Err(), os.ErrClosed) {
	// 			break
	// 		}
	// 	}
	// }()

	env := []string{
		fmt.Sprintf("GIT_TRACE2_EVENT=%v", tmpFile.Name()),
		fmt.Sprintf("GIT_TRACE2_PARENT_SID=%s", correlation.ExtractFromContextOrGenerate(ctx)),
	}

	return env, func() {
		// Closing this file will cause the go routine to abort
		if err := tmpFile.Close(); err != nil {
			ctxlogrus.Extract(ctx).WithError(err).Error("failed to close TRACE2 temp file")
		}
		if err := os.Remove(tmpFile.Name()); err != nil {
			ctxlogrus.Extract(ctx).WithError(err).Error("failed to remove TRACE2 temp file")
		}
	}, nil
}
